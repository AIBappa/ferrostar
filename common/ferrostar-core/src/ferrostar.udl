//
// Namespace to encapsulate top-level functions
//

namespace ferrostar {
    RouteRequestGenerator create_valhalla_request_generator(string endpoint_url, string profile);
    RouteResponseParser create_osrm_response_parser(u32 polyline_precision);
};

//
// Error types
//

[Error]
enum RoutingRequestGenerationError {
    "NotEnoughWaypoints",
    "JsonError",
    "UnknownError"
};

[Error]
interface RoutingResponseParseError {
    ParseError(string error);
    UnknownError();
};

//
// Data structures
//

dictionary GeographicCoordinates {
    double lat;
    double lng;
};

dictionary CourseOverGround {
    u16 degrees;
    u16 accuracy;
};

dictionary UserLocation {
    GeographicCoordinates coordinates;
    double horizontal_accuracy;
    CourseOverGround? course_over_ground;
    timestamp timestamp;
};

dictionary Route {
    sequence<GeographicCoordinates> geometry;
    double distance;
    sequence<GeographicCoordinates> waypoints;
    sequence<RouteStep> steps;
};

dictionary RouteStep {
    sequence<GeographicCoordinates> geometry;
    double distance;
    string? road_name;
    string instruction;
    sequence<VisualInstructions> visual_instructions;
};

dictionary SpokenInstruction {
    string text;
    string? ssml;
    f64 trigger_distance_before_maneuver;
};

dictionary VisualInstructions {
    VisualInstructionContent primary_content;
    VisualInstructionContent? secondary_content;
    f64 trigger_distance_before_maneuver;
};

dictionary VisualInstructionContent {
    string text;
    ManeuverType? maneuver_type;
    ManeuverModifier? maneuver_modifier;
    u16? roundabout_exit_degrees;
};

enum ManeuverType {
    "Turn",
    "NewName",
    "Depart",
    "Arrive",
    "Merge",
    "OnRamp",
    "OffRamp",
    "Fork",
    "EndOfRoad",
    "Continue",
    "Roundabout",
    "Rotary",
    "RoundaboutTurn",
    "Notification",
    "ExitRoundabout",
    "ExitRotary",
};

enum ManeuverModifier {
    "UTurn",
    "SharpRight",
    "Right",
    "SlightRight",
    "Straight",
    "SlightLeft",
    "Left",
    "SharpLeft",
};

[Enum]
interface RouteRequest {
    HttpPost(string url, record<DOMString, string> headers, sequence<u8> body);
};

[Enum]
interface NavigationStateUpdate {
    Navigating(UserLocation snapped_user_location, sequence<GeographicCoordinates> remaining_waypoints, RouteStep current_step, VisualInstructions? visual_instructions, SpokenInstruction? spoken_instruction);
    Arrived(VisualInstructions? visual_instructions, SpokenInstruction? spoken_instruction);
};

[Enum]
interface StepAdvanceMode {
    Manual();
    DistanceToEndOfStep(u16 distance, u16 minimum_horizontal_accuracy);
    RelativeLineStringDistance(u16 minimum_horizontal_accuracy);
};

dictionary NavigationControllerConfig {
    StepAdvanceMode step_advance;
};

//
// Callback interfaces (foreign code can implement these to extend functionality)
//

callback interface RouteRequestGenerator {
    [Throws=RoutingRequestGenerationError]
    RouteRequest generate_request(UserLocation user_location, sequence<GeographicCoordinates> waypoints);
};

callback interface RouteResponseParser {
    [Throws=RoutingResponseParseError]
    sequence<Route> parse_response(sequence<u8> response);
};

//
// Concrete core objects
//

interface RouteAdapter {
    constructor(RouteRequestGenerator request_generator, RouteResponseParser response_parser);
    [Name=new_valhalla_http]
    constructor(string endpoint_url, string profile);

    [Throws=RoutingRequestGenerationError]
    RouteRequest generate_request(UserLocation user_location, sequence<GeographicCoordinates> waypoints);

    [Throws=RoutingResponseParseError]
    sequence<Route> parse_response(sequence<u8> response);
};

interface NavigationController {
    constructor(UserLocation last_user_location, Route route, NavigationControllerConfig config);

    NavigationStateUpdate advance_to_next_step();
    NavigationStateUpdate update_user_location(UserLocation location);
};