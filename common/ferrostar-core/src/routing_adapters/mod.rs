use crate::{
    create_osrm_response_parser, create_valhalla_request_generator,
    models::{GeographicCoordinates, Route, UserLocation},
};
use error::{RoutingRequestGenerationError, RoutingResponseParseError};
use std::collections::HashMap;
use std::fmt::Debug;

pub mod error;
pub mod osrm;
pub mod valhalla;

/// A route request generated by a [RouteRequestGenerator].
#[derive(PartialEq, Debug)]
pub enum RouteRequest {
    HttpPost {
        url: String,
        headers: HashMap<String, String>,
        body: Vec<u8>,
    },
    // TODO: Generic case for cases like local/offline route generation or other arbitrary foreign code
}

// TODO: Conventions on constructor arguments? Setter methods??
/// A trait describing any object capable of generating [RouteRequest]s.
///
/// The interface is intentionally generic. Every routing backend has its own set of
/// parameters, including a "profile," max travel speed, units of speed and distance, and more.
/// It is assumed that these properties will be set at construction time or otherwise configured
/// before use, so that we can keep the public interface as generic as possible.
///
/// Implementations may be either in Rust (most popular engines should eventually have Rust
/// implementations) or foreign code.
pub trait RouteRequestGenerator: Send + Sync + Debug {
    /// Generates a routing backend request given the set of locations.
    ///
    /// While most implementations will treat the locations as an ordered sequence, this is not
    /// guaranteed (ex: an optimized router)..
    /// TODO: Option for whether we should account for course over ground or heading.
    fn generate_request(
        &self,
        user_location: UserLocation,
        waypoints: Vec<GeographicCoordinates>,
    ) -> Result<RouteRequest, RoutingRequestGenerationError>;

    // TODO: "Trace attributes" request method? Maybe in a separate trait?
}

/// A generic interface describing any object capable of parsing a response from a routing
/// backend into one or more [Route]s.
pub trait RouteResponseParser: Send + Sync + Debug {
    /// Parses a raw response from the routing backend into a route.
    ///
    /// As we need to assume some sort of type, a sequence of octets is a reasonable interchange
    /// format for all known responses so far (JSON, PBF, etc.).
    fn parse_response(&self, response: Vec<u8>) -> Result<Vec<Route>, RoutingResponseParseError>;
}

/// The route adapter bridges between the common core and a routing backend.
///
/// This is essentially the composite of the [RouteRequestGenerator] and [RouteResponseParser]
/// traits, but it provides one further level of abstraction which is helpful to consumers.
/// As there is no way to signal compatibility between request generators and response parsers,
/// the [RouteAdapter] provides convenience constructors which take the guesswork out of it,
/// while still leaving consumers free to implement one or both halves.
///
/// In the future, we may provide additional methods or conveniences, and this
/// indirection leaves the design open to such changes without necessarily breaking source
/// compatibility.
///
/// Ideas  welcome re: how to signal compatibility between request generators and response parsers.
/// I don't think we can do this in the type system, since one of the reasons for the split design
/// is modularity, including the possibility of user-provided implementations, and these will not
/// always be of a "known" type to the Rust side.
pub struct RouteAdapter {
    request_generator: Box<dyn RouteRequestGenerator>,
    response_parser: Box<dyn RouteResponseParser>,
}

impl RouteAdapter {
    pub fn new(
        request_generator: Box<dyn RouteRequestGenerator>,
        response_parser: Box<dyn RouteResponseParser>,
    ) -> Self {
        Self {
            request_generator,
            response_parser,
        }
    }

    pub fn new_valhalla_http(endpoint_url: String, profile: String) -> Self {
        let request_generator = create_valhalla_request_generator(endpoint_url, profile);
        let response_parser = create_osrm_response_parser(6);
        Self::new(request_generator, response_parser)
    }

    //
    // Proxied implementation methods.
    //

    pub fn generate_request(
        &self,
        user_location: UserLocation,
        waypoints: Vec<GeographicCoordinates>,
    ) -> Result<RouteRequest, RoutingRequestGenerationError> {
        self.request_generator
            .generate_request(user_location, waypoints)
    }

    pub fn parse_response(
        &self,
        response: Vec<u8>,
    ) -> Result<Vec<Route>, RoutingResponseParseError> {
        self.response_parser.parse_response(response)
    }
}
